#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "../include/doctest.h"
#include "../include/sha256.hpp"
#include "../include/json.hpp"
#include <fstream>
#include <sstream>
#include <iomanip>
#include <algorithm>

using json = nlohmann::json;

/**
 * @brief Structure to hold a SHA256 test vector.
 */
struct Sha256TestVector
{
    std::string input;
    std::string expected_hash;
};

/**
 * @brief Trims whitespace from both ends of a string.
 * @param str The string to trim.
 * @return The trimmed string.
 */
std::string trim(const std::string &str)
{
    // Find the first non-whitespace character
    const auto start = str.find_first_not_of(" \t\n\r\f\v");
    if (start == std::string::npos)
        return "";

    // Find the last non-whitespace character
    const auto end = str.find_last_not_of(" \t\n\r\f\v");
    // Return the substring without leading/trailing whitespace
    return str.substr(start, end - start + 1);
}

/**
 * @brief Converts a hexadecimal string to a vector of bytes.
 * @param hex The hex string.
 * @return The corresponding byte vector.
 */
std::vector<uint8_t> hexToBytes(const std::string &hex)
{
    std::string clean = trim(hex);

    if (clean.empty())
        return {};

    if (clean.size() % 2 != 0)
        throw std::runtime_error("Hex string must have even length");

    std::vector<uint8_t> bytes;
    // Convert each pair of hex digits to a byte
    for (size_t i = 0; i < clean.size(); i += 2)
    {
        std::string byteString = clean.substr(i, 2); // Extract two characters
        if (!isxdigit(byteString[0]) || !isxdigit(byteString[1])) // Check if both characters are valid hex digits
            throw std::runtime_error("Invalid hex digit in input: " + byteString); // Throw an error if not valid
        bytes.push_back(static_cast<uint8_t>(std::stoi(byteString, nullptr, 16))); // Convert to byte
    }
    return bytes;
}

/**
 * @brief Converts a vector of bytes to a string.
 * @param bytes The byte vector.
 * @return The corresponding string.
 */
std::string bytesToString(const std::vector<uint8_t> &bytes)
{
    // Construct a string from the byte vector
    return std::string(bytes.begin(), bytes.end());
}

/**
 * @brief Converts a vector of bytes to a hexadecimal string.
 * @param bytes The byte vector.
 * @return The corresponding hex string.
 */
std::string bytesToHex(const std::vector<uint8_t> &bytes)
{
    std::ostringstream oss;
    // Convert each byte to a two-character hex string
    for (uint8_t byte : bytes)
        oss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(byte);
    return oss.str();
}

/**
 * @brief Test random SHA256 vectors generated by Python.
 *        Loads test vectors from a JSON file and checks that the hash matches.
 */
TEST_CASE("SHA256 random test vectors from Python")
{
    std::ifstream file("test_vectors.json");
    REQUIRE(file.is_open());

    json vectors;
    file >> vectors;

    for (const auto &vec : vectors)
    {
        std::string input = vec["input"];
        std::string expected = vec["hash"];
        std::string actual = SHA256::hash(input);

        // Check that the computed hash matches the expected hash
        CHECK_MESSAGE(actual == expected,
                      "Input: " << input << "\nExpected: " << expected << "\nActual: " << actual);
    }
}

/**
 * @brief Test known SHA256 vectors from the standard.
 *        Checks a few well-known input/output pairs.
 */
TEST_CASE("SHA256 known vectors")
{
    // Empty string
    CHECK_MESSAGE(SHA256::hash("") ==
                      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
                  "Input: \"\"");
    // "abc"
    CHECK_MESSAGE(SHA256::hash("abc") ==
                      "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
                  "Input: \"abc\"");
    // "hello world"
    CHECK_MESSAGE(SHA256::hash("hello world") ==
                      "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9",
                  "Input: \"hello world\"");
}

/**
 * @brief Test di-mgt.org SHA256 test vectors, including large and edge cases.
 *        Includes very large input to test implementation limits.
 */
TEST_CASE("di-mgt Test vectors")
{
    std::vector<Sha256TestVector> sha256_test_vectors = {
        // Standard test vectors
        {"abc", "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"},
        {"", "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"},
        {"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq",
         "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1"},
        {"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu",
         "cf5b16a778af8380036ce59e7b0492370b249b11e8f07a51afac45037afee9d1"},
        // 1 million 'a's
        {std::string(1000000, 'a'),
         "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0"},
#ifndef SKIP_LARGE_SHA256_TEST
        // The following test is 1GB of data, only run if not skipping large tests
        {[]()
         {
             std::string pattern = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno";
             std::string result;
             result.reserve(pattern.size() * 16777216);
             // Concatenate the pattern 16,777,216 times
             for (int i = 0; i < 16777216; ++i)
                 result += pattern;
             return result;
         }(),
         "50e72a0e26442fe2552dc3938ac58658228c0cbfb1d2ca872ae435266fcd055e"}
#endif
    };

    for (const auto &test : sha256_test_vectors)
    {
        // Compute the hash for the test input
        std::string actual = SHA256::hash(test.input);
        // Print input length for large cases
        CHECK_MESSAGE(actual == test.expected_hash,
                      "Input: (length=" << test.input.size() << ")\nExpected: " << test.expected_hash << "\nActual: " << actual);
    }
}

/**
 * @brief Test NIST SHA256 ShortMsg vectors from official test files.
 *        Only tests messages whose bit length is a multiple of 8 (full bytes).
 */
TEST_CASE("NIST SHA256 ShortMsg vectors")
{
    std::ifstream file("NIST_Test_vectors/SHA256ShortMsg.rsp");
    REQUIRE(file.is_open());

    std::string line, msg_hex, expected_hash;
    int bit_length = 0;

    while (std::getline(file, line))
    {
        // Skip comments and blank lines
        if (line.empty() || line[0] == '#')
            continue;

        // Parse bit length
        if (line.rfind("Len =", 0) == 0)
        {
            bit_length = std::stoi(line.substr(5));
        }
        // Parse message hex string
        else if (line.rfind("Msg =", 0) == 0)
        {
            msg_hex = line.substr(6);
        }
        // Parse expected hash and run the test
        else if (line.rfind("MD =", 0) == 0)
        {
            expected_hash = trim(line.substr(4));

            // Only test full-byte inputs (bit length is a multiple of 8)
            if (bit_length % 8 != 0)
                continue;

            // Convert hex to raw bytes and then to string
            std::string input_str;
            if (!msg_hex.empty() && bit_length > 0)
            {
                std::vector<uint8_t> msg_bytes = hexToBytes(msg_hex);
                // Construct string from bytes for hashing
                input_str = std::string(reinterpret_cast<const char *>(msg_bytes.data()), msg_bytes.size());
            }
            else
            {
                input_str = ""; // Handle empty hex string as empty input
            }
            // Compute the SHA256 hash
            std::string hash = SHA256::hash(input_str);

            // Print detailed info if the hash does not match
            CHECK_MESSAGE(hash == expected_hash,
                          "Failed for input (hex): " << msg_hex << "\n"
                                                     << "Bit length: " << bit_length << "\n"
                                                     << "Expected: " << expected_hash << "\n"
                                                     << "Got: " << hash << "\n");
        }
    }
}

/**
 * @brief Test NIST SHA256 LongMsg vectors from official test files.
 *        Only tests messages whose bit length is a multiple of 8 (full bytes).
 */
TEST_CASE("NIST SHA256 LongMsg vectors")
{
    std::ifstream file("NIST_Test_vectors/SHA256LongMsg.rsp");
    REQUIRE(file.is_open());

    std::string line, msg_hex, expected_hash;
    int bit_length = 0;

    while (std::getline(file, line))
    {
        // Skip comments and blank lines
        if (line.empty() || line[0] == '#')
            continue;

        // Parse bit length
        if (line.rfind("Len =", 0) == 0)
        {
            bit_length = std::stoi(line.substr(5));
        }
        // Parse message hex string
        else if (line.rfind("Msg =", 0) == 0)
        {
            msg_hex = line.substr(5);
        }
        // Parse expected hash and run the test
        else if (line.rfind("MD =", 0) == 0)
        {
            expected_hash = trim(line.substr(4));

            // Only test full-byte inputs (bit length is a multiple of 8)
            if (bit_length % 8 != 0)
                continue;

            std::string input_str;
            if (!msg_hex.empty() && bit_length > 0)
            {
                std::vector<uint8_t> msg_bytes = hexToBytes(msg_hex);
                // Construct string from bytes for hashing
                input_str = std::string(reinterpret_cast<const char *>(msg_bytes.data()), msg_bytes.size());
            }
            else
            {
                input_str = ""; // Handle empty hex string as empty input
            }
            // Compute the SHA256 hash
            std::string hash = SHA256::hash(input_str);

            // Print detailed info if the hash does not match
            CHECK_MESSAGE(hash == expected_hash,
                          "Failed for input (hex): " << msg_hex << "\n"
                                                     << "Bit length: " << bit_length << "\n"
                                                     << "Expected: " << expected_hash << "\n"
                                                     << "Got: " << hash << "\n");
        }
    }
}

/**
 * @brief Test NIST Monte Carlo SHA256 test vectors.
 *        For each COUNT, performs 1000 iterations of hashing M0||M1||M2 and checks the final result.
 *        Each COUNT block starts with a Seed, and the expected hash is compared after 1000 iterations.
 */
TEST_CASE("NIST Monte Carlo SHA256 test vectors")
{
    std::ifstream file("NIST_Test_vectors/SHA256Monte.rsp");
    REQUIRE(file.is_open());

    std::string line;
    int count = -1;

    while (std::getline(file, line))
    {
        // Skip comments and section headers
        if (line.empty() || line[0] == '#' || line[0] == '[')
            continue;

        // Start of a new COUNT block
        if (line.rfind("COUNT = ", 0) == 0)
        {
            count = std::stoi(line.substr(8));

            // Read the next line which should be the Seed
            std::getline(file, line);
            if (line.rfind("Seed = ", 0) == 0)
            {
                // Parse the seed as bytes
                auto seed = hexToBytes(trim(line.substr(7)));
                std::vector<uint8_t> M0 = seed;
                std::vector<uint8_t> M1 = seed;
                std::vector<uint8_t> M2 = seed;

                // Perform 1000 iterations for this COUNT
                for (int j = 0; j < 1000; ++j)
                {
                    // Concatenate M0 || M1 || M2 to form the input
                    std::vector<uint8_t> combined;
                    combined.insert(combined.end(), M0.begin(), M0.end());
                    combined.insert(combined.end(), M1.begin(), M1.end());
                    combined.insert(combined.end(), M2.begin(), M2.end());

                    // Convert to string for the hash function
                    std::string input = std::string(combined.begin(), combined.end());

                    // Get hash as hex string
                    std::string md_hex = SHA256::hash(input);

                    // Convert hex string back to bytes for next iteration
                    std::vector<uint8_t> md_bytes = hexToBytes(md_hex);

                    // Update for next iteration: M0 = M1, M1 = M2, M2 = MD
                    M0 = M1;
                    M1 = M2;
                    M2 = md_bytes;
                }

                // Read the expected MD line
                std::getline(file, line);
                if (line.rfind("MD = ", 0) == 0)
                {
                    std::string expected_md = trim(line.substr(5));
                    std::string actual_md = bytesToHex(M2);

                    // Convert to lowercase for comparison
                    std::transform(actual_md.begin(), actual_md.end(), actual_md.begin(), ::tolower);
                    std::transform(expected_md.begin(), expected_md.end(), expected_md.begin(), ::tolower);

                    // Print detailed info if the hash does not match
                    CHECK_MESSAGE(actual_md == expected_md,
                                  "Monte Carlo test failed for COUNT = " << count << "\n"
                                                                         << "Seed: " << bytesToHex(seed) << "\n"
                                                                         << "Expected: " << expected_md << "\n"
                                                                         << "Got:      " << actual_md << "\n");
                }
            }
        }
    }
}